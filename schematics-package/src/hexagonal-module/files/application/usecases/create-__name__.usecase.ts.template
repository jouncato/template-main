import { Injectable, Inject<% if (database !== 'none') { %>, Logger<% } %> } from '@nestjs/common';
<% if (database !== 'none') { %>import { I<%= classify(moduleName) %>Repository } from '../../domain/ports/i-<%= dasherize(moduleName) %>-repository.port';<% } %>
<% if (kafka === 'producer' || kafka === 'both') { %>import { I<%= classify(moduleName) %>EventPublisher } from '../../domain/ports/i-<%= dasherize(moduleName) %>-event-publisher.port';<% } %>
<% if (database !== 'none') { %>import { <%= classify(moduleName) %>DomainService } from '../../domain/services/<%= dasherize(moduleName) %>-domain.service';<% } %>
import { <%= classify(moduleName) %>Entity } from '../../domain/entities/<%= dasherize(moduleName) %>.entity';
import { Create<%= classify(moduleName) %>Dto } from '../dtos/create-<%= dasherize(moduleName) %>.dto';
import { <%= classify(moduleName) %>ResponseDto } from '../dtos/<%= dasherize(moduleName) %>-response.dto';

/**
 * Use Case: Create <%= classify(moduleName) %>
 *
 * This use case orchestrates the creation of a new <%= classify(moduleName) %> entity.
 * It follows the hexagonal architecture pattern by depending on port interfaces
 * rather than concrete implementations.
 *
 * Responsibilities:
 * 1. Validate business rules through domain service
 * 2. Create the domain entity
 * 3. Persist via repository port
 * 4. Publish domain events via event publisher port
 * 5. Return response DTO to the caller
 *
 * Flow:
 * Controller -> UseCase -> Domain Service -> Repository & Event Publisher
 *
 * Dependencies are injected using NestJS DI with interface tokens,
 * allowing adapters to be swapped without changing this use case.
 *
 * @example
 * ```typescript
 * const dto = new Create<%= classify(moduleName) %>Dto();
 * dto.name = 'Example';
 * const result = await createUseCase.execute(dto);
 * ```
 */
@Injectable()
export class Create<%= classify(moduleName) %>UseCase {
<% if (database !== 'none') { %>  private readonly logger = new Logger(Create<%= classify(moduleName) %>UseCase.name);
<% } %>
  constructor(
<% if (database !== 'none') { %>    // Inject repository port (interface) - not the concrete adapter
    @Inject(I<%= classify(moduleName) %>Repository)
    private readonly repository: I<%= classify(moduleName) %>Repository,

    // Inject domain service for business logic validation
    private readonly domainService: <%= classify(moduleName) %>DomainService,
<% } %>
<% if (kafka === 'producer' || kafka === 'both') { %>    // Inject event publisher port (interface) - not the concrete adapter
    @Inject(I<%= classify(moduleName) %>EventPublisher)
    private readonly eventPublisher: I<%= classify(moduleName) %>EventPublisher,
<% } %>
  ) {}

  /**
   * Executes the create <%= dasherize(moduleName) %> use case
   *
   * This method orchestrates the entire creation process:
   * 1. Validates the input DTO (already validated by class-validator)
   * 2. Applies domain business rules
   * 3. Creates the domain entity
   * 4. Persists the entity
   * 5. Publishes a domain event
   * 6. Returns the response DTO
   *
   * @param dto - The data transfer object containing creation data
   * @returns Promise resolving to the created <%= dasherize(moduleName) %> as a response DTO
   * @throws {BadRequestException} If business rules are violated
   * @throws {ConflictException} If a duplicate entity exists
   * @throws {InternalServerErrorException} If persistence fails
   *
   * @example
   * ```typescript
   * const dto = new Create<%= classify(moduleName) %>Dto();
   * dto.name = 'Example';
   * dto.description = 'Test description';
   * const response = await useCase.execute(dto);
   * console.log(response.id); // UUID of created entity
   * ```
   */
  async execute(dto: Create<%= classify(moduleName) %>Dto): Promise<<%= classify(moduleName) %>ResponseDto> {
<% if (database !== 'none') { %>    this.logger.log(`Creating new <%= dasherize(moduleName) %>: ${dto.name}`);
<% } %>
    try {
<% if (database !== 'none') { %>      // Step 1: Apply domain business rules and validations
      // The domain service contains pure business logic
      await this.domainService.validateForCreation(dto);

<% } %>      // Step 2: Create the domain entity
      // The entity encapsulates domain logic and invariants
      const entity = <%= classify(moduleName) %>Entity.create({
        id: crypto.randomUUID(),
        name: dto.name,
        description: dto.description,
        status: dto.isActive === false ? 'INACTIVE' : 'ACTIVE'
      });

<% if (database !== 'none') { %>      // Step 3: Persist the entity through the repository port
      // The actual storage mechanism is abstracted by the port interface
      const savedEntity = await this.repository.save(entity);

      this.logger.log(`<%= classify(moduleName) %> created successfully with ID: ${savedEntity.id}`);

<% } %><% if (kafka === 'producer' || kafka === 'both') { %>      // Step 4: Publish domain event for eventual consistency
      // Other bounded contexts can react to this event
      await this.eventPublisher.publishCreated({
        eventId: crypto.randomUUID(),
        eventType: '<%= dasherize(moduleName) %>.created',
        version: '1.0',
        timestamp: new Date(),
        data: {
          id: <% if (database !== 'none') { %>savedEntity<% } else { %>entity<% } %>.id,
          name: <% if (database !== 'none') { %>savedEntity<% } else { %>entity<% } %>.name,
          status: <% if (database !== 'none') { %>savedEntity<% } else { %>entity<% } %>.status,
          description: <% if (database !== 'none') { %>savedEntity<% } else { %>entity<% } %>.description,
          createdAt: <% if (database !== 'none') { %>savedEntity<% } else { %>entity<% } %>.createdAt,
          updatedAt: <% if (database !== 'none') { %>savedEntity<% } else { %>entity<% } %>.updatedAt
        }
      });

<% } %>      // Step 5: Transform domain entity to response DTO
      // This provides a clean separation between domain and API layers
      return <%= classify(moduleName) %>ResponseDto.fromEntity(<% if (database !== 'none') { %>savedEntity<% } else { %>entity<% } %>);
    } catch (error) {
<% if (database !== 'none') { %>      this.logger.error(`Failed to create <%= dasherize(moduleName) %>: ${error.message}`, error.stack);
<% } %>
      // Re-throw domain exceptions (BadRequestException, ConflictException, etc.)
      // These will be handled by NestJS exception filters
      throw error;
    }
  }
}
