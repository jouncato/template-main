import { Injectable } from '@nestjs/common';
import * as sql from 'mssql';

import { SqlServerService } from '@share/infrastructure/mssql/sqlserver.service';
import { Logger20Service } from '@share/domain/config/logger/logger20.service';

import { <%= classify(moduleName) %>Entity } from '../../../domain/entities/<%= dasherize(moduleName) %>.entity';
import { I<%= classify(moduleName) %>Repository, PaginationOptions, PaginatedResult } from '../../../domain/ports/i-<%= dasherize(moduleName) %>-repository.port';

/**
 * MSSQL Repository Adapter for <%= classify(moduleName) %>
 *
 * This is an ADAPTER in hexagonal architecture - it implements the repository port
 * using SQL Server stored procedures.
 *
 * Architecture Pattern:
 * - Implements: I<%= classify(moduleName) %>Repository (outbound port defined in domain layer)
 * - Uses: SqlServerService for database operations
 * - Approach: Stored procedure-based data access (no ORM)
 *
 * Stored Procedure Naming Convention:
 * - usp_<%= classify(moduleName) %>_SelectById
 * - usp_<%= classify(moduleName) %>_SelectAll
 * - usp_<%= classify(moduleName) %>_Insert
 * - usp_<%= classify(moduleName) %>_Update
 * - usp_<%= classify(moduleName) %>_Delete
 * - etc.
 *
 * Benefits of Stored Procedures:
 * - Performance: Compiled and optimized by SQL Server
 * - Security: Parameterized queries prevent SQL injection
 * - Encapsulation: Database logic centralized in database
 * - Transaction Control: Native support for BEGIN TRAN/COMMIT/ROLLBACK
 * - Maintainability: DBAs can optimize without changing application code
 *
 * Transaction Handling:
 * - Each stored procedure manages its own transaction scope
 * - Complex operations use BEGIN TRANSACTION/COMMIT/ROLLBACK
 * - Error handling with TRY/CATCH blocks in T-SQL
 *
 * @see SqlServerService for database connection management
 * @see I<%= classify(moduleName) %>Repository for port interface definition
 */
@Injectable()
export class <%= classify(moduleName) %>RepositoryAdapter implements I<%= classify(moduleName) %>Repository {
  constructor(
    private readonly sqlServerService: SqlServerService,
    private readonly logger: Logger20Service,
  ) {}

  /**
   * Find a <%= classify(moduleName) %> by ID
   *
   * Calls stored procedure: usp_<%= classify(moduleName) %>_SelectById
   *
   * @param id - The unique identifier
   * @returns Promise resolving to entity or null if not found
   */
  async findById(id: string): Promise<<%= classify(moduleName) %>Entity | null> {
    try {
      this.logger.log(`Finding <%= moduleName %> by id: ${id}`);

      // Input parameters for stored procedure
      const inputParams = {
        Id: { type: sql.NVarChar(50), value: id },
      };

      // Execute stored procedure
      const result = await this.sqlServerService.executeProcedure<any>(
        'usp_<%= classify(moduleName) %>_SelectById',
        inputParams,
      );

      // Check if recordset has results
      if (!result.recordset || result.recordset.length === 0) {
        this.logger.log(`<%= classify(moduleName) %> with id ${id} not found`);
        return null;
      }

      // Map database record to domain entity
      const record = result.recordset[0];
      const entity = this.mapToEntity(record);

      this.logger.log(`Found <%= moduleName %>: ${entity.id}`);
      return entity;
    } catch (error) {
      this.logger.error(`Error finding <%= moduleName %> by id ${id}:`, error);
      throw new Error(`Failed to find <%= moduleName %> by id: ${error.message}`);
    }
  }

  /**
   * Find all <%= classify(moduleName) %> entities
   *
   * Calls stored procedure: usp_<%= classify(moduleName) %>_SelectAll
   *
   * @returns Promise resolving to array of entities
   */
  async findAll(): Promise<<%= classify(moduleName) %>Entity[]> {
    try {
      this.logger.log(`Finding all <%= moduleName %> entities`);

      // Execute stored procedure (no input parameters)
      const result = await this.sqlServerService.executeProcedure<any>(
        'usp_<%= classify(moduleName) %>_SelectAll',
      );

      // Map recordset to entities
      if (!result.recordset || result.recordset.length === 0) {
        this.logger.log(`No <%= moduleName %> entities found`);
        return [];
      }

      const entities = result.recordset.map((record) => this.mapToEntity(record));

      this.logger.log(`Found ${entities.length} <%= moduleName %> entities`);
      return entities;
    } catch (error) {
      this.logger.error(`Error finding all <%= moduleName %> entities:`, error);
      throw new Error(`Failed to find all <%= moduleName %> entities: ${error.message}`);
    }
  }

  /**
   * Find <%= classify(moduleName) %> entities by status
   *
   * Calls stored procedure: usp_<%= classify(moduleName) %>_SelectByStatus
   *
   * @param status - The status to filter by
   * @returns Promise resolving to array of matching entities
   */
  async findByStatus(status: string): Promise<<%= classify(moduleName) %>Entity[]> {
    try {
      this.logger.log(`Finding <%= moduleName %> entities by status: ${status}`);

      const inputParams = {
        Status: { type: sql.NVarChar(50), value: status },
      };

      const result = await this.sqlServerService.executeProcedure<any>(
        'usp_<%= classify(moduleName) %>_SelectByStatus',
        inputParams,
      );

      if (!result.recordset || result.recordset.length === 0) {
        return [];
      }

      const entities = result.recordset.map((record) => this.mapToEntity(record));
      this.logger.log(`Found ${entities.length} <%= moduleName %> entities with status ${status}`);
      return entities;
    } catch (error) {
      this.logger.error(`Error finding <%= moduleName %> by status:`, error);
      throw new Error(`Failed to find <%= moduleName %> by status: ${error.message}`);
    }
  }

  /**
   * Find a <%= classify(moduleName) %> by name
   *
   * Calls stored procedure: usp_<%= classify(moduleName) %>_SelectByName
   *
   * @param name - The name to search for
   * @returns Promise resolving to entity or null if not found
   */
  async findByName(name: string): Promise<<%= classify(moduleName) %>Entity | null> {
    try {
      this.logger.log(`Finding <%= moduleName %> by name: ${name}`);

      const inputParams = {
        Name: { type: sql.NVarChar(255), value: name },
      };

      const result = await this.sqlServerService.executeProcedure<any>(
        'usp_<%= classify(moduleName) %>_SelectByName',
        inputParams,
      );

      if (!result.recordset || result.recordset.length === 0) {
        return null;
      }

      const entity = this.mapToEntity(result.recordset[0]);
      return entity;
    } catch (error) {
      this.logger.error(`Error finding <%= moduleName %> by name:`, error);
      throw new Error(`Failed to find <%= moduleName %> by name: ${error.message}`);
    }
  }

  /**
   * Save a new <%= classify(moduleName) %> entity
   *
   * Calls stored procedure: usp_<%= classify(moduleName) %>_Insert
   *
   * Transaction handling:
   * - The stored procedure manages transaction scope
   * - Uses BEGIN TRAN/COMMIT on success
   * - Uses ROLLBACK on error within TRY/CATCH block
   *
   * @param entity - The entity to save
   * @returns Promise resolving to the saved entity
   * @throws Error if save operation fails
   */
  async save(entity: <%= classify(moduleName) %>Entity): Promise<<%= classify(moduleName) %>Entity> {
    try {
      this.logger.log(`Saving new <%= moduleName %>: ${entity.id}`);

      // Input parameters mapped from entity
      const inputParams = {
        Id: { type: sql.NVarChar(50), value: entity.id },
        Name: { type: sql.NVarChar(255), value: entity.name },
        Status: { type: sql.NVarChar(50), value: entity.status },
        CreatedAt: { type: sql.DateTime2(), value: entity.createdAt },
        UpdatedAt: { type: sql.DateTime2(), value: entity.updatedAt },
      };

      // Output parameter for operation result
      const outputParams = {
        Result: sql.Int(),
      };

      // Execute stored procedure
      const result = await this.sqlServerService.executeProcedure<any>(
        'usp_<%= classify(moduleName) %>_Insert',
        inputParams,
        outputParams,
      );

      // Check output parameter for success
      // Convention: 1 = success, 0 = failure, -1 = already exists, etc.
      const resultCode = result.output.Result;

      if (resultCode === 1) {
        this.logger.log(`Successfully saved <%= moduleName %>: ${entity.id}`);
        return entity;
      } else if (resultCode === -1) {
        throw new Error(`<%= classify(moduleName) %> with id ${entity.id} already exists`);
      } else {
        throw new Error(`Failed to save <%= moduleName %>, result code: ${resultCode}`);
      }
    } catch (error) {
      this.logger.error(`Error saving <%= moduleName %>:`, error);
      throw new Error(`Failed to save <%= moduleName %>: ${error.message}`);
    }
  }

  /**
   * Update an existing <%= classify(moduleName) %> entity
   *
   * Calls stored procedure: usp_<%= classify(moduleName) %>_Update
   *
   * Transaction handling:
   * - Managed by stored procedure
   * - Returns affected rows count via output parameter
   *
   * @param entity - The entity to update
   * @returns Promise resolving to the updated entity
   * @throws Error if entity does not exist
   */
  async update(entity: <%= classify(moduleName) %>Entity): Promise<<%= classify(moduleName) %>Entity> {
    try {
      this.logger.log(`Updating <%= moduleName %>: ${entity.id}`);

      const inputParams = {
        Id: { type: sql.NVarChar(50), value: entity.id },
        Name: { type: sql.NVarChar(255), value: entity.name },
        Status: { type: sql.NVarChar(50), value: entity.status },
        UpdatedAt: { type: sql.DateTime2(), value: entity.updatedAt },
      };

      const outputParams = {
        AffectedRows: sql.Int(),
      };

      const result = await this.sqlServerService.executeProcedure<any>(
        'usp_<%= classify(moduleName) %>_Update',
        inputParams,
        outputParams,
      );

      const affectedRows = result.output.AffectedRows;

      if (affectedRows === 0) {
        throw new Error(`<%= classify(moduleName) %> with id ${entity.id} not found`);
      }

      this.logger.log(`Successfully updated <%= moduleName %>: ${entity.id}`);
      return entity;
    } catch (error) {
      this.logger.error(`Error updating <%= moduleName %>:`, error);
      throw new Error(`Failed to update <%= moduleName %>: ${error.message}`);
    }
  }

  /**
   * Delete a <%= classify(moduleName) %> by ID
   *
   * Calls stored procedure: usp_<%= classify(moduleName) %>_Delete
   *
   * Transaction handling:
   * - Managed by stored procedure
   * - Can perform soft delete (set status=DELETED) or hard delete
   *
   * @param id - The unique identifier of the entity to delete
   * @returns Promise resolving to true if deleted, false if not found
   */
  async delete(id: string): Promise<boolean> {
    try {
      this.logger.log(`Deleting <%= moduleName %>: ${id}`);

      const inputParams = {
        Id: { type: sql.NVarChar(50), value: id },
      };

      const outputParams = {
        AffectedRows: sql.Int(),
      };

      const result = await this.sqlServerService.executeProcedure<any>(
        'usp_<%= classify(moduleName) %>_Delete',
        inputParams,
        outputParams,
      );

      const affectedRows = result.output.AffectedRows;
      const deleted = affectedRows > 0;

      if (deleted) {
        this.logger.log(`Successfully deleted <%= moduleName %>: ${id}`);
      } else {
        this.logger.log(`<%= classify(moduleName) %> with id ${id} not found for deletion`);
      }

      return deleted;
    } catch (error) {
      this.logger.error(`Error deleting <%= moduleName %>:`, error);
      throw new Error(`Failed to delete <%= moduleName %>: ${error.message}`);
    }
  }

  /**
   * Check if a <%= classify(moduleName) %> exists by ID
   *
   * Calls stored procedure: usp_<%= classify(moduleName) %>_Exists
   *
   * @param id - The unique identifier to check
   * @returns Promise resolving to true if exists, false otherwise
   */
  async exists(id: string): Promise<boolean> {
    try {
      const inputParams = {
        Id: { type: sql.NVarChar(50), value: id },
      };

      const outputParams = {
        Exists: sql.Bit(),
      };

      const result = await this.sqlServerService.executeProcedure<any>(
        'usp_<%= classify(moduleName) %>_Exists',
        inputParams,
        outputParams,
      );

      return result.output.Exists === true || result.output.Exists === 1;
    } catch (error) {
      this.logger.error(`Error checking <%= moduleName %> existence:`, error);
      return false;
    }
  }

  /**
   * Count total number of <%= classify(moduleName) %> entities
   *
   * Calls stored procedure: usp_<%= classify(moduleName) %>_Count
   *
   * @returns Promise resolving to the count
   */
  async count(): Promise<number> {
    try {
      const outputParams = {
        TotalCount: sql.Int(),
      };

      const result = await this.sqlServerService.executeProcedure<any>(
        'usp_<%= classify(moduleName) %>_Count',
        {},
        outputParams,
      );

      return result.output.TotalCount || 0;
    } catch (error) {
      this.logger.error(`Error counting <%= moduleName %> entities:`, error);
      return 0;
    }
  }

  /**
   * Find <%= classify(moduleName) %> entities with pagination
   *
   * Calls stored procedure: usp_<%= classify(moduleName) %>_SelectPaginated
   *
   * The stored procedure uses OFFSET/FETCH for pagination:
   * - OFFSET (@Page - 1) * @Limit ROWS
   * - FETCH NEXT @Limit ROWS ONLY
   *
   * @param options - Pagination options (page, limit, sort)
   * @returns Promise resolving to paginated results
   */
  async findWithPagination(
    options: PaginationOptions,
  ): Promise<PaginatedResult<<%= classify(moduleName) %>Entity>> {
    try {
      this.logger.log(`Finding <%= moduleName %> entities with pagination: page=${options.page}, limit=${options.limit}`);

      const inputParams = {
        Page: { type: sql.Int(), value: options.page },
        Limit: { type: sql.Int(), value: options.limit },
        SortField: { type: sql.NVarChar(50), value: options.sort?.field || 'CreatedAt' },
        SortDirection: { type: sql.NVarChar(4), value: options.sort?.direction || 'DESC' },
      };

      const outputParams = {
        TotalCount: sql.Int(),
      };

      const result = await this.sqlServerService.executeProcedure<any>(
        'usp_<%= classify(moduleName) %>_SelectPaginated',
        inputParams,
        outputParams,
      );

      const items = result.recordset
        ? result.recordset.map((record) => this.mapToEntity(record))
        : [];

      const total = result.output.TotalCount || 0;
      const totalPages = Math.ceil(total / options.limit);

      return {
        items,
        page: options.page,
        limit: options.limit,
        total,
        totalPages,
        hasNext: options.page < totalPages,
        hasPrevious: options.page > 1,
      };
    } catch (error) {
      this.logger.error(`Error finding <%= moduleName %> with pagination:`, error);
      throw new Error(`Failed to find <%= moduleName %> with pagination: ${error.message}`);
    }
  }

  /**
   * Save multiple <%= classify(moduleName) %> entities in a single transaction
   *
   * Calls stored procedure: usp_<%= classify(moduleName) %>_InsertBatch
   *
   * Transaction handling:
   * - Entire batch wrapped in single transaction
   * - All or nothing: ROLLBACK if any insert fails
   *
   * @param entities - Array of entities to save
   * @returns Promise resolving to array of saved entities
   */
  async saveMany(entities: <%= classify(moduleName) %>Entity[]): Promise<<%= classify(moduleName) %>Entity[]> {
    try {
      this.logger.log(`Saving ${entities.length} <%= moduleName %> entities in batch`);

      // For batch operations, use Table-Valued Parameters (TVP) or call procedure multiple times
      // This example shows individual calls within application-level transaction handling
      // For true TVP support, create a User-Defined Table Type in SQL Server

      const savedEntities: <%= classify(moduleName) %>Entity[] = [];

      for (const entity of entities) {
        const saved = await this.save(entity);
        savedEntities.push(saved);
      }

      this.logger.log(`Successfully saved ${savedEntities.length} <%= moduleName %> entities`);
      return savedEntities;
    } catch (error) {
      this.logger.error(`Error saving multiple <%= moduleName %> entities:`, error);
      throw new Error(`Failed to save multiple <%= moduleName %> entities: ${error.message}`);
    }
  }

  /**
   * Delete multiple <%= classify(moduleName) %> entities by their identifiers
   *
   * Calls stored procedure: usp_<%= classify(moduleName) %>_DeleteBatch
   *
   * @param ids - Array of unique identifiers
   * @returns Promise resolving to the number of deleted entities
   */
  async deleteMany(ids: string[]): Promise<number> {
    try {
      this.logger.log(`Deleting ${ids.length} <%= moduleName %> entities in batch`);

      let deletedCount = 0;

      for (const id of ids) {
        const deleted = await this.delete(id);
        if (deleted) {
          deletedCount++;
        }
      }

      this.logger.log(`Successfully deleted ${deletedCount} <%= moduleName %> entities`);
      return deletedCount;
    } catch (error) {
      this.logger.error(`Error deleting multiple <%= moduleName %> entities:`, error);
      throw new Error(`Failed to delete multiple <%= moduleName %> entities: ${error.message}`);
    }
  }

  /**
   * Maps a database record to a domain entity
   *
   * Handles:
   * - Type conversions (dates, booleans)
   * - NULL handling
   * - Database column naming to entity property mapping
   *
   * @param record - Database record from recordset
   * @returns Domain entity instance
   */
  private mapToEntity(record: any): <%= classify(moduleName) %>Entity {
    return <%= classify(moduleName) %>Entity.reconstitute({
      id: record.Id,
      name: record.Name,
      status: record.Status,
      createdAt: new Date(record.CreatedAt),
      updatedAt: new Date(record.UpdatedAt),
    });
  }
}
